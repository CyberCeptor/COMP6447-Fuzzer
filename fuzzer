#!/usr/bin/env python3
import subprocess
import sys
from time import sleep
import breakpoint_finder
import format_finder
import threading
import _thread as thread
import random
from scipy.optimize import minimize, Bounds
from combiner import apply, get_dim
import breakpoint_finder
import multiprocessing
from mutator_plaintext import *
from mutator_json import *

program = sys.argv[1]
input = sys.argv[2]

with open(input, "rb") as f:
    sample_text = f.read()

lock = threading.Lock()
def write_out_bad(text: bytes):
    """
    Write out the failing text. Also acquire a lock and kill the fuzzer to stop
    it immediately and to prevent multiple writers.
    """
    lock.acquire() # never release so that nothing else can possibly write out.
    with open("bad.txt", "wb") as f:
        f.write(text)
    thread.interrupt_main()

def get_mutators(text):
    # Always have the plaintext ones.
    mutators = [SubstringMutator(), BitFlipMutator(), ByteFlipMutator(),
        RepeatMutator(), EmptyMutator()]
    if format_finder.try_csv(text):
        #mutators.append(CSVMutator())
        pass
    if format_finder.try_json(text):
        mutators.extend([JsonIntMutator(), JsonExtremeIntMutator(), 
        JsonFloatMutator(), JsonFloatNanMutator(), JsonListRepeatMutator(),
        JsonEntryRepeatMutator(), JsonChangeTypeMutator()])
    if format_finder.try_xml(text):
        #mutators.append(XMLMutator())
        pass
    if format_finder.try_jpg(text):
        #mutators.append(JPGMutator())
        pass
    if format_finder.try_elf(text):
        #mutators.append(ELFMutator())
        pass
    return mutators

breakpoints = breakpoint_finder.get(program)
mutators = get_mutators(sample_text)

CRASH_VALUE = -100000000

def count_coverage(gdb_instance, input: bytes) -> int:
    # Run and count breakpoints hit for the given input.
    # No resetting needed because the run command does that for us.

    curr_thread = threading.current_thread().ident

    f = open(f'/tmp/input{curr_thread}', 'wb')
    f.write(input)
    f.close()

    # Temporary to just get it running.
    # p = subprocess.run(program, input=input, timeout=1.0, capture_output=True)
    timer = threading.Timer(40.0, gdb_instance.kill)
    try:
        timer.start()
        gdb_instance.stdin.write(f'run < /tmp/input{curr_thread}\n'.encode())

        print('after input:', gdb_instance.stdout.readlines())

        gdb_instance.stdin.write('info breakpoints\n'.encode())
        
        print('breakpoint info:', gdb_instance.stdout.readlines())

        # print(gdb_instance.stderr.readlines())

        # print('return code:', gdb_instance.returncode)

        stdout, stderr = gdb_instance.communicate()

        print('after communicate:', gdb_instance.returncode)

        if gdb_instance.returncode != 0:
            print('v bad')
            write_out_bad(input)

        count = 0 # set to specific value if a crash instead.
        if count == CRASH_VALUE:
            # write it out and kill the fuzzer.
            write_out_bad(input)
    finally:
        # gdb_instance.stdin.write('info breakpoints\n'.encode())
        # print('time is up: ', gdb_instance.stdout.readlines())
        print('time is up')
        timer.cancel()

    # The output should be negated so that minimize works correctly.
    return -random.random()

def thread_run():
    # make gdb instance. Apply breakpoints
    gdb_instance = subprocess.Popen(['gdb', '--nx', program], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    set_breakpoints = breakpoint_finder.gdb_command_str(program)[0]
    gdb_instance.stdin.write(set_breakpoints.encode())

    breakpoints_cmd = breakpoint_finder.gdb_command_str(program)[1]
    gdb_instance.stdin.write(breakpoints_cmd.encode())
    print(gdb_instance)

    # get a random sequence of mutators to apply.
    num_choices = random.randrange(0, len(mutators) * 2)
    methods = random.choices(mutators, k=num_choices)
    if get_dim(methods) < 1:
        return

    objective = lambda vec: count_coverage(gdb_instance, apply(sample_text, methods, vec))
    # Begin minimisation from a random starting vector.
    bounds = Bounds(0, 1)
    minimize(objective, np.random.rand(get_dim(methods)), bounds=bounds)

def fuzz():
    import os
    # Setting a reasonable limit so that the cpu doesn't die.
    cpus = os.cpu_count()
    if cpus is None:
        max_threads = 8
    else:
        max_threads = cpus * 2 + 1
    #max_threads = 2 # for debugging purposes. Lets one thread at a time.

    while True:
        try:
            # Distribute work out and keeping trying until something crashes.
            while threading.active_count() < max_threads:
                t = threading.Thread(target=thread_run, daemon=True)
                t.start()
            sleep(1.0)
        except KeyboardInterrupt:
            print("Exiting")
            break

def try_empty():
    try:
        p = subprocess.run(program, input=b"", timeout=1.0, capture_output=True)
        if p.returncode != 0:
            write_out_bad("")
    except subprocess.TimeoutExpired:
        # timed out.
        pass

def try_repeat():
    while True:
        repeat = random.randrange(0, 100000)
        input = sample_text * repeat
        try:
            p = subprocess.run(program, input=input, timeout=1.0, capture_output=True)
            if p.returncode != 0:
                write_out_bad(input)
        except subprocess.TimeoutExpired:
            # timed out.
            pass

def try_simple():
    # Start threads for the simple cases
    threading.Thread(target=try_empty, daemon=True).start()
    threading.Thread(target=try_repeat, daemon=True).start()

def main():
    try:
        try_simple()
        fuzz()
    except Exception as e:
        print(e.args)
        # Marker that we finished.
        # program exit will kill all the threads

if __name__ == "__main__":
    fuzz()
